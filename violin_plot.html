<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Violin Plot Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .axis path, .axis line {
            fill: none;
            shape-rendering: crispEdges;
        }
    </style>
</head>
<body>
    <h1>Interactive Violin Plot</h1>
    <label for="sheet-select">Select a Sheet:</label>
    <select id="sheet-select"></select>
    <div id="plot"></div>

    <script>
        // Load JSON data
        const dataFile = "sheets_data.json";
        d3.json(dataFile).then(data => {
            // Populate dropdown
            const dropdown = d3.select("#sheet-select");
            Object.keys(data).forEach(sheet => {
                dropdown.append("option").text(sheet).attr("value", sheet);
            });

            // Draw the initial plot
            drawViolinPlot(data[Object.keys(data)[0]]);

            // Update plot on dropdown change
            dropdown.on("change", function () {
                const selectedSheet = this.value;
                drawViolinPlot(data[selectedSheet]);
            });
        });

        // Draw Violin Plot
        function drawViolinPlot(dataset) {
            const width = 800, height = 400, margin = { top: 30, right: 30, bottom: 50, left: 50 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            // Clear previous plot
            d3.select("#plot").html("");

            // Create SVG canvas
            const svg = d3.select("#plot")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(dataset))
                .range([margin.left, innerWidth + margin.left]);

            const yScale = d3.scaleLinear()
                .domain([0, 1])
                .range([innerHeight + margin.top, margin.top]);

            // Kernel density estimation
            const kde = kernelDensityEstimator(kernelEpanechnikov(0.5), xScale.ticks(40));
            const density = kde(dataset);

            // Draw the density area
            svg.append("path")
                .datum(density)
                .attr("fill", "#69b3a2")
                .attr("stroke", "#000")
                .attr("stroke-width", 1)
                .attr("d", d3.line()
                    .curve(d3.curveBasis)
                    .x(d => xScale(d[0]))
                    .y(d => yScale(d[1])));

            // Add X Axis
            svg.append("g")
                .attr("transform", `translate(0,${innerHeight + margin.top})`)
                .call(d3.axisBottom(xScale));

            // Add Y Axis
            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(yScale));

            // KDE Helper Functions
            function kernelDensityEstimator(kernel, X) {
                return function(V) {
                    return X.map(x => [x, d3.mean(V, v => kernel(x - v))]);
                };
            }

            function kernelEpanechnikov(k) {
                return function(v) {
                    return Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
                };
            }
        }
    </script>
</body>
</html>
